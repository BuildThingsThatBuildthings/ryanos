/**\n * Safety rules and progression management for workout generation\n * @file safety-rules.js\n */\n\nclass SafetyRulesEngine {\n  constructor() {\n    this.rules = {\n      // Anti-overlap rules\n      movement_patterns: {\n        squat: { recovery_hours: 48, max_consecutive: 2 },\n        hinge: { recovery_hours: 48, max_consecutive: 2 },\n        horizontal_push: { recovery_hours: 36, max_consecutive: 2 },\n        vertical_push: { recovery_hours: 36, max_consecutive: 2 },\n        horizontal_pull: { recovery_hours: 36, max_consecutive: 2 },\n        vertical_pull: { recovery_hours: 36, max_consecutive: 2 },\n        lunge: { recovery_hours: 24, max_consecutive: 3 }\n      },\n      \n      // Muscle group recovery requirements\n      muscle_groups: {\n        quadriceps: { recovery_hours: 48, high_intensity_hours: 72 },\n        hamstrings: { recovery_hours: 48, high_intensity_hours: 72 },\n        glutes: { recovery_hours: 36, high_intensity_hours: 48 },\n        chest: { recovery_hours: 36, high_intensity_hours: 48 },\n        back: { recovery_hours: 36, high_intensity_hours: 48 },\n        shoulders: { recovery_hours: 24, high_intensity_hours: 36 },\n        biceps: { recovery_hours: 24, high_intensity_hours: 36 },\n        triceps: { recovery_hours: 24, high_intensity_hours: 36 },\n        calves: { recovery_hours: 24, high_intensity_hours: 24 },\n        core: { recovery_hours: 24, high_intensity_hours: 48 }\n      },\n      \n      // RPE limits by experience level\n      rpe_limits: {\n        beginner: { max_rpe: 8, high_rpe_sessions_per_week: 1 },\n        intermediate: { max_rpe: 9, high_rpe_sessions_per_week: 2 },\n        advanced: { max_rpe: 10, high_rpe_sessions_per_week: 3 }\n      },\n      \n      // Volume progression limits\n      progression: {\n        weekly_volume_increase: 0.10, // 10% max per week\n        weekly_intensity_increase: 0.05, // 5% max per week\n        monthly_volume_increase: 0.25, // 25% max per month\n        deload_frequency: 4, // Every 4 weeks\n        deload_reduction: 0.4 // 40% volume reduction during deload\n      },\n      \n      // Fatigue management\n      fatigue: {\n        high_fatigue_threshold: 7, // On 1-10 scale\n        moderate_fatigue_threshold: 5,\n        recovery_rpe_limit: 6,\n        consecutive_high_intensity_limit: 3\n      }\n    };\n  }\n\n  /**\n   * Check if a planned workout violates safety rules\n   * @param {Object} plannedWorkout - The workout plan to validate\n   * @param {Array} trainingHistory - Recent training history\n   * @param {Object} userProfile - User fitness profile\n   * @returns {Object} Safety validation result\n   */\n  validateWorkoutSafety(plannedWorkout, trainingHistory, userProfile) {\n    const violations = [];\n    const warnings = [];\n    const recommendations = [];\n\n    // Check movement pattern overlaps\n    const movementViolations = this.checkMovementPatternOverlap(\n      plannedWorkout, trainingHistory\n    );\n    violations.push(...movementViolations.violations);\n    warnings.push(...movementViolations.warnings);\n\n    // Check muscle group recovery\n    const muscleViolations = this.checkMuscleGroupRecovery(\n      plannedWorkout, trainingHistory\n    );\n    violations.push(...muscleViolations.violations);\n    warnings.push(...muscleViolations.warnings);\n\n    // Check RPE limits\n    const rpeViolations = this.checkRPELimits(\n      plannedWorkout, userProfile, trainingHistory\n    );\n    violations.push(...rpeViolations.violations);\n    warnings.push(...rpeViolations.warnings);\n\n    // Check progression rates\n    const progressionViolations = this.checkProgressionRates(\n      plannedWorkout, trainingHistory\n    );\n    violations.push(...progressionViolations.violations);\n    warnings.push(...progressionViolations.warnings);\n\n    // Check fatigue status\n    const fatigueCheck = this.assessFatigueStatus(\n      plannedWorkout, trainingHistory, userProfile\n    );\n    warnings.push(...fatigueCheck.warnings);\n    recommendations.push(...fatigueCheck.recommendations);\n\n    // Generate overall safety rating\n    const safetyRating = this.calculateSafetyRating(\n      violations.length, warnings.length\n    );\n\n    return {\n      is_safe: violations.length === 0,\n      safety_rating: safetyRating,\n      violations,\n      warnings,\n      recommendations,\n      requires_deload: this.shouldRecommendDeload(trainingHistory),\n      suggested_modifications: this.generateSafetyModifications(\n        violations, warnings, plannedWorkout\n      )\n    };\n  }\n\n  /**\n   * Check for movement pattern overlap violations\n   */\n  checkMovementPatternOverlap(plannedWorkout, trainingHistory) {\n    const violations = [];\n    const warnings = [];\n    \n    const plannedPatterns = this.extractMovementPatterns(plannedWorkout);\n    const recentPatterns = this.getRecentMovementPatterns(trainingHistory, 3); // Last 3 days\n    \n    plannedPatterns.forEach(pattern => {\n      const rule = this.rules.movement_patterns[pattern.name];\n      if (!rule) return;\n      \n      const recentUsage = recentPatterns[pattern.name] || [];\n      const timeSinceLastUse = this.getTimeSinceLastUse(recentUsage);\n      \n      // Check if pattern was used too recently with high intensity\n      if (timeSinceLastUse < rule.recovery_hours && pattern.intensity > 7) {\n        violations.push({\n          type: 'movement_pattern_overlap',\n          pattern: pattern.name,\n          hours_since_last: timeSinceLastUse,\n          required_recovery: rule.recovery_hours,\n          planned_intensity: pattern.intensity\n        });\n      }\n      \n      // Check for consecutive high-intensity sessions\n      const consecutiveDays = this.getConsecutiveDays(recentUsage);\n      if (consecutiveDays >= rule.max_consecutive && pattern.intensity > 7) {\n        warnings.push({\n          type: 'consecutive_pattern_warning',\n          pattern: pattern.name,\n          consecutive_days: consecutiveDays,\n          max_allowed: rule.max_consecutive\n        });\n      }\n    });\n    \n    return { violations, warnings };\n  }\n\n  /**\n   * Check muscle group recovery requirements\n   */\n  checkMuscleGroupRecovery(plannedWorkout, trainingHistory) {\n    const violations = [];\n    const warnings = [];\n    \n    const plannedMuscleGroups = this.extractMuscleGroups(plannedWorkout);\n    const recentMuscleWork = this.getRecentMuscleGroupWork(trainingHistory, 5); // Last 5 days\n    \n    plannedMuscleGroups.forEach(muscleGroup => {\n      const rule = this.rules.muscle_groups[muscleGroup.name];\n      if (!rule) return;\n      \n      const recentWork = recentMuscleWork[muscleGroup.name] || [];\n      const lastHighIntensity = this.getLastHighIntensityWork(recentWork);\n      \n      if (lastHighIntensity) {\n        const hoursSince = this.calculateHoursBetween(\n          lastHighIntensity.date, new Date()\n        );\n        \n        const requiredRecovery = lastHighIntensity.intensity > 8 \n          ? rule.high_intensity_hours \n          : rule.recovery_hours;\n        \n        if (hoursSince < requiredRecovery && muscleGroup.intensity > 6) {\n          violations.push({\n            type: 'muscle_group_recovery',\n            muscle_group: muscleGroup.name,\n            hours_since_last: hoursSince,\n            required_recovery: requiredRecovery,\n            last_intensity: lastHighIntensity.intensity,\n            planned_intensity: muscleGroup.intensity\n          });\n        }\n      }\n    });\n    \n    return { violations, warnings };\n  }\n\n  /**\n   * Check RPE limits based on user experience\n   */\n  checkRPELimits(plannedWorkout, userProfile, trainingHistory) {\n    const violations = [];\n    const warnings = [];\n    \n    const fitnessLevel = userProfile.fitness_level || 'beginner';\n    const limits = this.rules.rpe_limits[fitnessLevel];\n    \n    // Check overall workout RPE\n    if (plannedWorkout.overall_rpe_target > limits.max_rpe) {\n      violations.push({\n        type: 'rpe_limit_exceeded',\n        planned_rpe: plannedWorkout.overall_rpe_target,\n        max_allowed: limits.max_rpe,\n        user_level: fitnessLevel\n      });\n    }\n    \n    // Check high RPE session frequency\n    const recentHighRPESessions = this.countRecentHighRPESessions(\n      trainingHistory, limits.max_rpe - 1\n    );\n    \n    if (plannedWorkout.overall_rpe_target >= limits.max_rpe - 1 &&\n        recentHighRPESessions >= limits.high_rpe_sessions_per_week) {\n      warnings.push({\n        type: 'high_rpe_frequency',\n        recent_high_sessions: recentHighRPESessions,\n        max_per_week: limits.high_rpe_sessions_per_week,\n        planned_rpe: plannedWorkout.overall_rpe_target\n      });\n    }\n    \n    return { violations, warnings };\n  }\n\n  /**\n   * Check progression rates for safety\n   */\n  checkProgressionRates(plannedWorkout, trainingHistory) {\n    const violations = [];\n    const warnings = [];\n    \n    if (trainingHistory.length < 7) {\n      warnings.push({\n        type: 'insufficient_history',\n        message: 'Insufficient training history for progression analysis'\n      });\n      return { violations, warnings };\n    }\n    \n    // Calculate recent averages\n    const recentVolume = this.calculateAverageVolume(trainingHistory, 7);\n    const plannedVolume = this.estimateWorkoutVolume(plannedWorkout);\n    const volumeIncrease = (plannedVolume - recentVolume) / recentVolume;\n    \n    // Check volume progression\n    if (volumeIncrease > this.rules.progression.weekly_volume_increase) {\n      violations.push({\n        type: 'excessive_volume_increase',\n        increase_percentage: (volumeIncrease * 100).toFixed(1),\n        max_allowed: (this.rules.progression.weekly_volume_increase * 100).toFixed(1),\n        recent_volume: recentVolume.toFixed(0),\n        planned_volume: plannedVolume.toFixed(0)\n      });\n    }\n    \n    // Check intensity progression\n    const recentIntensity = this.calculateAverageIntensity(trainingHistory, 7);\n    const intensityIncrease = (plannedWorkout.overall_rpe_target - recentIntensity) / recentIntensity;\n    \n    if (intensityIncrease > this.rules.progression.weekly_intensity_increase) {\n      warnings.push({\n        type: 'rapid_intensity_increase',\n        increase_percentage: (intensityIncrease * 100).toFixed(1),\n        recent_intensity: recentIntensity.toFixed(1),\n        planned_intensity: plannedWorkout.overall_rpe_target\n      });\n    }\n    \n    return { violations, warnings };\n  }\n\n  /**\n   * Assess current fatigue status\n   */\n  assessFatigueStatus(plannedWorkout, trainingHistory, userProfile) {\n    const warnings = [];\n    const recommendations = [];\n    \n    const fatigueScore = this.calculateOverallFatigue(trainingHistory);\n    const thresholds = this.rules.fatigue;\n    \n    if (fatigueScore >= thresholds.high_fatigue_threshold) {\n      warnings.push({\n        type: 'high_fatigue_detected',\n        fatigue_score: fatigueScore,\n        threshold: thresholds.high_fatigue_threshold\n      });\n      \n      recommendations.push({\n        type: 'reduce_intensity',\n        message: 'Consider reducing workout intensity or taking a rest day',\n        suggested_rpe_limit: thresholds.recovery_rpe_limit\n      });\n    } else if (fatigueScore >= thresholds.moderate_fatigue_threshold) {\n      warnings.push({\n        type: 'moderate_fatigue_detected',\n        fatigue_score: fatigueScore,\n        threshold: thresholds.moderate_fatigue_threshold\n      });\n    }\n    \n    // Check for consecutive high-intensity sessions\n    const consecutiveHighIntensity = this.countConsecutiveHighIntensity(trainingHistory);\n    if (consecutiveHighIntensity >= thresholds.consecutive_high_intensity_limit) {\n      recommendations.push({\n        type: 'break_intensity_cycle',\n        message: 'Consider a lower intensity session to break the high-intensity cycle',\n        consecutive_count: consecutiveHighIntensity\n      });\n    }\n    \n    return { warnings, recommendations };\n  }\n\n  /**\n   * Calculate overall safety rating\n   */\n  calculateSafetyRating(violationCount, warningCount) {\n    if (violationCount > 0) return 'unsafe';\n    if (warningCount > 3) return 'risky';\n    if (warningCount > 1) return 'moderate';\n    if (warningCount > 0) return 'good';\n    return 'excellent';\n  }\n\n  /**\n   * Check if deload should be recommended\n   */\n  shouldRecommendDeload(trainingHistory) {\n    if (trainingHistory.length < 14) return false;\n    \n    const weeklyAverages = this.calculateWeeklyAverages(trainingHistory);\n    const currentWeek = weeklyAverages[0]; // Most recent week\n    const previousWeeks = weeklyAverages.slice(1, 4); // Previous 3 weeks\n    \n    // Check if in 4th week of cycle with high intensity\n    const highIntensityWeeks = previousWeeks.filter(week => week.avg_rpe > 8).length;\n    const isDeloadTime = highIntensityWeeks >= 3;\n    \n    // Check accumulated fatigue\n    const totalFatigue = this.calculateOverallFatigue(trainingHistory);\n    const isHighFatigue = totalFatigue >= this.rules.fatigue.high_fatigue_threshold;\n    \n    return isDeloadTime || isHighFatigue;\n  }\n\n  /**\n   * Generate safety-based workout modifications\n   */\n  generateSafetyModifications(violations, warnings, plannedWorkout) {\n    const modifications = [];\n    \n    violations.forEach(violation => {\n      switch (violation.type) {\n        case 'movement_pattern_overlap':\n          modifications.push({\n            type: 'substitute_exercise',\n            target_pattern: violation.pattern,\n            reason: 'Insufficient recovery from recent training'\n          });\n          break;\n          \n        case 'muscle_group_recovery':\n          modifications.push({\n            type: 'reduce_intensity',\n            target_muscle: violation.muscle_group,\n            suggested_rpe_reduction: 2\n          });\n          break;\n          \n        case 'rpe_limit_exceeded':\n          modifications.push({\n            type: 'cap_rpe',\n            max_rpe: violation.max_allowed,\n            reason: 'User experience level limitation'\n          });\n          break;\n          \n        case 'excessive_volume_increase':\n          modifications.push({\n            type: 'reduce_volume',\n            reduction_percentage: 20,\n            reason: 'Excessive progression rate'\n          });\n          break;\n      }\n    });\n    \n    return modifications;\n  }\n\n  // Helper methods for calculations and data extraction\n  extractMovementPatterns(workout) {\n    // Extract movement patterns from workout plan\n    const patterns = [];\n    \n    workout.blocks.forEach(block => {\n      block.exercises.forEach(exercise => {\n        const pattern = this.inferMovementPattern(exercise.exercise_name);\n        if (pattern) {\n          patterns.push({\n            name: pattern,\n            intensity: this.calculateExerciseIntensity(exercise)\n          });\n        }\n      });\n    });\n    \n    return patterns;\n  }\n\n  extractMuscleGroups(workout) {\n    const muscleGroups = [];\n    \n    workout.blocks.forEach(block => {\n      block.exercises.forEach(exercise => {\n        // This would need access to exercise database for muscle group mapping\n        const muscles = this.inferMuscleGroups(exercise.exercise_name);\n        muscles.forEach(muscle => {\n          muscleGroups.push({\n            name: muscle,\n            intensity: this.calculateExerciseIntensity(exercise)\n          });\n        });\n      });\n    });\n    \n    return muscleGroups;\n  }\n\n  calculateExerciseIntensity(exercise) {\n    // Calculate intensity based on sets, reps, and RPE\n    const avgRPE = exercise.sets.reduce((sum, set) => sum + set.rpe, 0) / exercise.sets.length;\n    return avgRPE;\n  }\n\n  getRecentMovementPatterns(history, days) {\n    const cutoff = new Date();\n    cutoff.setDate(cutoff.getDate() - days);\n    \n    const patterns = {};\n    \n    history\n      .filter(workout => new Date(workout.date) >= cutoff)\n      .forEach(workout => {\n        // Extract patterns from historical workouts\n        Object.keys(workout.movement_pattern_volume || {}).forEach(pattern => {\n          if (!patterns[pattern]) patterns[pattern] = [];\n          patterns[pattern].push({\n            date: workout.date,\n            intensity: workout.overall_rpe || 0\n          });\n        });\n      });\n    \n    return patterns;\n  }\n\n  getRecentMuscleGroupWork(history, days) {\n    const cutoff = new Date();\n    cutoff.setDate(cutoff.getDate() - days);\n    \n    const muscleWork = {};\n    \n    history\n      .filter(workout => new Date(workout.date) >= cutoff)\n      .forEach(workout => {\n        Object.keys(workout.muscle_group_volume || {}).forEach(muscle => {\n          if (!muscleWork[muscle]) muscleWork[muscle] = [];\n          muscleWork[muscle].push({\n            date: workout.date,\n            intensity: workout.overall_rpe || 0,\n            volume: workout.muscle_group_volume[muscle] || 0\n          });\n        });\n      });\n    \n    return muscleWork;\n  }\n\n  calculateOverallFatigue(history) {\n    // Simplified fatigue calculation\n    // In a real system, this would be more sophisticated\n    if (history.length < 3) return 0;\n    \n    const recent = history.slice(0, 7); // Last 7 days\n    const avgRPE = recent.reduce((sum, w) => sum + (w.overall_rpe || 0), 0) / recent.length;\n    const frequency = recent.length;\n    \n    // Simple fatigue model: higher RPE and frequency = more fatigue\n    return Math.min((avgRPE / 10) * frequency, 10);\n  }\n\n  calculateAverageVolume(history, days) {\n    const recent = history.slice(0, days);\n    return recent.reduce((sum, w) => sum + (w.total_volume_kg || 0), 0) / recent.length;\n  }\n\n  calculateAverageIntensity(history, days) {\n    const recent = history.slice(0, days);\n    return recent.reduce((sum, w) => sum + (w.overall_rpe || 0), 0) / recent.length;\n  }\n\n  estimateWorkoutVolume(workout) {\n    let totalVolume = 0;\n    \n    workout.blocks.forEach(block => {\n      block.exercises.forEach(exercise => {\n        exercise.sets.forEach(set => {\n          totalVolume += (set.weight || 0) * (set.reps || 0);\n        });\n      });\n    });\n    \n    return totalVolume;\n  }\n\n  // Additional helper methods would go here...\n  inferMovementPattern(exerciseName) {\n    // Map exercise names to movement patterns\n    const patterns = {\n      squat: 'squat',\n      deadlift: 'hinge',\n      'bench press': 'horizontal_push',\n      'overhead press': 'vertical_push',\n      'bent over row': 'horizontal_pull',\n      pullup: 'vertical_pull',\n      lunge: 'lunge'\n    };\n    \n    const name = exerciseName.toLowerCase();\n    for (const [key, pattern] of Object.entries(patterns)) {\n      if (name.includes(key)) return pattern;\n    }\n    \n    return null;\n  }\n\n  inferMuscleGroups(exerciseName) {\n    // Simplified muscle group inference\n    const name = exerciseName.toLowerCase();\n    if (name.includes('squat')) return ['quadriceps', 'glutes'];\n    if (name.includes('deadlift')) return ['hamstrings', 'glutes', 'back'];\n    if (name.includes('bench')) return ['chest', 'triceps'];\n    if (name.includes('row')) return ['back', 'biceps'];\n    return ['unknown'];\n  }\n\n  getTimeSinceLastUse(usageArray) {\n    if (!usageArray.length) return Infinity;\n    const lastUse = new Date(Math.max(...usageArray.map(u => new Date(u.date))));\n    return this.calculateHoursBetween(lastUse, new Date());\n  }\n\n  calculateHoursBetween(date1, date2) {\n    return Math.abs(date2 - date1) / (1000 * 60 * 60);\n  }\n\n  getConsecutiveDays(usageArray) {\n    // Simplified consecutive day calculation\n    return usageArray.length; // This would need more sophisticated logic\n  }\n\n  getLastHighIntensityWork(workArray) {\n    return workArray\n      .filter(w => w.intensity > 7)\n      .sort((a, b) => new Date(b.date) - new Date(a.date))[0];\n  }\n\n  countRecentHighRPESessions(history, threshold) {\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n    \n    return history\n      .filter(w => new Date(w.date) >= oneWeekAgo)\n      .filter(w => w.overall_rpe >= threshold)\n      .length;\n  }\n\n  countConsecutiveHighIntensity(history) {\n    let count = 0;\n    for (let i = 0; i < history.length; i++) {\n      if (history[i].overall_rpe > 8) {\n        count++;\n      } else {\n        break;\n      }\n    }\n    return count;\n  }\n\n  calculateWeeklyAverages(history) {\n    // Group workouts by week and calculate averages\n    const weeks = [];\n    let currentWeek = [];\n    let currentWeekStart = null;\n    \n    history.forEach(workout => {\n      const workoutDate = new Date(workout.date);\n      const weekStart = this.getWeekStart(workoutDate);\n      \n      if (!currentWeekStart || weekStart.getTime() !== currentWeekStart.getTime()) {\n        if (currentWeek.length > 0) {\n          weeks.push(this.calculateWeekSummary(currentWeek));\n        }\n        currentWeek = [workout];\n        currentWeekStart = weekStart;\n      } else {\n        currentWeek.push(workout);\n      }\n    });\n    \n    if (currentWeek.length > 0) {\n      weeks.push(this.calculateWeekSummary(currentWeek));\n    }\n    \n    return weeks;\n  }\n\n  getWeekStart(date) {\n    const weekStart = new Date(date);\n    weekStart.setDate(date.getDate() - date.getDay());\n    weekStart.setHours(0, 0, 0, 0);\n    return weekStart;\n  }\n\n  calculateWeekSummary(weekWorkouts) {\n    return {\n      workout_count: weekWorkouts.length,\n      avg_rpe: weekWorkouts.reduce((sum, w) => sum + (w.overall_rpe || 0), 0) / weekWorkouts.length,\n      total_volume: weekWorkouts.reduce((sum, w) => sum + (w.total_volume_kg || 0), 0),\n      avg_duration: weekWorkouts.reduce((sum, w) => sum + (w.duration_minutes || 0), 0) / weekWorkouts.length\n    };\n  }\n}\n\nmodule.exports = { SafetyRulesEngine };"