/**\n * Main LLM-based workout generation service\n * Integrates with OpenAI GPT-4 for intelligent workout programming\n * @file workout-generator.js\n */\n\nconst OpenAI = require('openai');\nconst { v4: uuidv4 } = require('uuid');\nconst { WorkoutValidator } = require('./validation');\nconst { LLMTools } = require('./llm-tools');\nconst { WorkoutPrompts } = require('./prompts');\n\nclass WorkoutGenerationService {\n  constructor(db, options = {}) {\n    this.db = db;\n    this.validator = new WorkoutValidator();\n    this.tools = new LLMTools(db);\n    \n    // Initialize OpenAI client\n    this.openai = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n      timeout: options.timeout || 60000\n    });\n    \n    this.model = options.model || 'gpt-4-turbo';\n    this.maxTokens = options.maxTokens || 4000;\n    this.temperature = options.temperature || 0.1; // Low temperature for consistency\n    \n    // Safety and progression settings\n    this.safetySettings = {\n      maxConsecutiveHeavyDays: 2,\n      progressionCap: 0.15, // 15% max increase\n      deloadFrequency: 4, // Every 4th week\n      maxRPEBeginner: 8,\n      maxRPEIntermediate: 9,\n      maxRPEAdvanced: 10\n    };\n  }\n\n  /**\n   * Generate a workout based on user request\n   * @param {string} userId - User identifier\n   * @param {string} request - Workout request description\n   * @param {Object} options - Generation options\n   * @returns {Promise<Object>} Generated workout with validation results\n   */\n  async generateWorkout(userId, request, options = {}) {\n    const startTime = Date.now();\n    const generationId = uuidv4();\n    \n    try {\n      // Step 1: Validate inputs\n      this.validateInputs(userId, request);\n      \n      // Step 2: Determine workout type and prepare context\n      const workoutContext = await this.prepareGenerationContext(userId, request, options);\n      \n      // Step 3: Check feasibility before generation\n      const feasibilityResult = await this.checkFeasibility(workoutContext);\n      if (!feasibilityResult.feasible) {\n        return {\n          success: false,\n          error: 'Workout not feasible with current constraints',\n          details: feasibilityResult.issues,\n          suggestions: feasibilityResult.suggestions\n        };\n      }\n      \n      // Step 4: Generate workout using LLM\n      const llmResponse = await this.callLLMGeneration(userId, workoutContext, options);\n      \n      // Step 5: Strict validation against exercise library\n      const validationResult = this.validator.validateWorkoutPlan(\n        llmResponse.workout_plan,\n        workoutContext.exercise_library.exercises,\n        workoutContext.recent_history,\n        workoutContext.constraints\n      );\n      \n      // Step 6: Handle validation results\n      if (!validationResult.is_valid) {\n        // Log failed generation for analysis\n        await this.logGenerationFailure(userId, request, validationResult, generationId);\n        \n        return {\n          success: false,\n          error: 'Generated workout failed validation',\n          validation_errors: validationResult.errors,\n          warnings: validationResult.warnings,\n          exercise_suggestions: validationResult.suggestions\n        };\n      }\n      \n      // Step 7: Apply final safety checks\n      const safetyResult = await this.applySafetyChecks(llmResponse.workout_plan, workoutContext);\n      if (!safetyResult.safe) {\n        return {\n          success: false,\n          error: 'Workout failed safety checks',\n          safety_issues: safetyResult.issues\n        };\n      }\n      \n      // Step 8: Create and save the workout\n      const generationMetadata = {\n        generation_id: generationId,\n        model: this.model,\n        prompt_tokens: llmResponse.usage?.prompt_tokens || 0,\n        completion_tokens: llmResponse.usage?.completion_tokens || 0,\n        total_tokens: llmResponse.usage?.total_tokens || 0,\n        generation_time: Date.now() - startTime,\n        request_text: request,\n        context_summary: this.summarizeContext(workoutContext)\n      };\n      \n      const creationResult = await this.tools.create_workout_plan(\n        userId,\n        llmResponse.workout_plan,\n        generationMetadata\n      );\n      \n      // Step 9: Log any exercise suggestions for future library updates\n      if (validationResult.suggestions.length > 0) {\n        await Promise.all(\n          validationResult.suggestions.map(suggestion =>\n            this.tools.log_exercise_suggestion(userId, suggestion)\n          )\n        );\n      }\n      \n      // Step 10: Log successful generation\n      await this.logGenerationSuccess(userId, creationResult.workout_id, generationMetadata);\n      \n      return {\n        success: true,\n        workout_id: creationResult.workout_id,\n        workout_plan: llmResponse.workout_plan,\n        validation_result: validationResult,\n        generation_metadata: generationMetadata,\n        exercise_suggestions: validationResult.suggestions,\n        rationale: llmResponse.rationale,\n        confidence_score: llmResponse.confidence_score\n      };\n      \n    } catch (error) {\n      await this.logGenerationError(userId, request, error, generationId);\n      \n      return {\n        success: false,\n        error: 'Workout generation failed',\n        details: error.message,\n        generation_id: generationId\n      };\n    }\n  }\n\n  /**\n   * Prepare comprehensive context for LLM generation\n   */\n  async prepareGenerationContext(userId, request, options) {\n    const context = {\n      user_id: userId,\n      request: request,\n      options: options\n    };\n    \n    try {\n      // Gather all context in parallel for efficiency\n      const [exerciseLibrary, summary7d, summary14d, equipment, constraints] = await Promise.all([\n        this.tools.get_exercise_library(userId),\n        this.tools.get_summary_7d(userId),\n        this.tools.get_summary_14d(userId),\n        this.tools.get_equipment_available(userId),\n        this.tools.get_user_constraints(userId)\n      ]);\n      \n      context.exercise_library = exerciseLibrary;\n      context.recent_history_7d = summary7d;\n      context.recent_history_14d = summary14d;\n      context.available_equipment = equipment.available_equipment;\n      context.constraints = constraints;\n      \n      // Determine if this is a deload week\n      context.is_deload_week = this.shouldDeload(summary14d);\n      \n      // Calculate current fatigue levels\n      context.fatigue_scores = this.calculateCurrentFatigue(summary7d);\n      \n      // Set volume and intensity targets\n      context.volume_targets = this.calculateVolumeTargets(summary14d, options);\n      \n      return context;\n      \n    } catch (error) {\n      throw new Error(`Failed to prepare generation context: ${error.message}`);\n    }\n  }\n\n  /**\n   * Check if the requested workout is feasible with current constraints\n   */\n  async checkFeasibility(context) {\n    const issues = [];\n    const suggestions = [];\n    \n    // Check exercise library coverage\n    if (context.exercise_library.total_exercises < 10) {\n      issues.push('Insufficient exercise library for comprehensive workout generation');\n      suggestions.push('Add more exercises to your library for better workout variety');\n    }\n    \n    // Check equipment requirements vs availability\n    const requiredEquipment = this.inferRequiredEquipment(context.request);\n    const missingEquipment = requiredEquipment.filter(eq => \n      !context.available_equipment.includes(eq)\n    );\n    \n    if (missingEquipment.length > 0) {\n      issues.push(`Missing required equipment: ${missingEquipment.join(', ')}`);\n      suggestions.push('Consider bodyweight alternatives or acquire missing equipment');\n    }\n    \n    // Check recovery status\n    if (context.recent_history_7d.recovery_status === 'needs_deload' && \n        !context.request.toLowerCase().includes('easy') &&\n        !context.request.toLowerCase().includes('recovery')) {\n      issues.push('User needs recovery/deload but requested high-intensity workout');\n      suggestions.push('Consider a recovery workout or reduce intensity');\n    }\n    \n    // Check time constraints\n    const requestedDuration = this.extractDurationFromRequest(context.request);\n    if (requestedDuration && requestedDuration > context.constraints.max_workout_duration) {\n      issues.push(`Requested duration exceeds user limit (${context.constraints.max_workout_duration} mins)`);\n      suggestions.push(`Reduce workout scope to fit within ${context.constraints.max_workout_duration} minutes`);\n    }\n    \n    return {\n      feasible: issues.length === 0,\n      issues,\n      suggestions\n    };\n  }\n\n  /**\n   * Call LLM for workout generation with function tools\n   */\n  async callLLMGeneration(userId, context, options) {\n    const prompt = this.buildGenerationPrompt(context, options);\n    const tools = this.tools.getToolDefinitions();\n    \n    // Create bound tool functions for the LLM\n    const boundTools = {\n      get_summary_7d: () => context.recent_history_7d,\n      get_summary_14d: () => context.recent_history_14d,\n      get_exercise_library: () => context.exercise_library,\n      get_equipment_available: () => ({ available_equipment: context.available_equipment }),\n      get_user_constraints: () => context.constraints,\n      create_workout_plan: (workout_plan) => ({ workout_plan, pending: true })\n    };\n    \n    try {\n      const completion = await this.openai.chat.completions.create({\n        model: this.model,\n        messages: [\n          { role: 'system', content: WorkoutPrompts.getSystemPrompt() },\n          { role: 'user', content: prompt }\n        ],\n        tools: tools,\n        tool_choice: 'auto',\n        max_tokens: this.maxTokens,\n        temperature: this.temperature,\n        response_format: { type: 'json_object' }\n      });\n      \n      const message = completion.choices[0].message;\n      \n      // Handle function calls if present\n      if (message.tool_calls) {\n        for (const toolCall of message.tool_calls) {\n          const functionName = toolCall.function.name;\n          const functionArgs = JSON.parse(toolCall.function.arguments);\n          \n          if (boundTools[functionName]) {\n            const result = boundTools[functionName](functionArgs);\n            // Tool results would be fed back to LLM in a real implementation\n          }\n        }\n      }\n      \n      // Parse the response\n      const responseContent = message.content;\n      const llmResponse = JSON.parse(responseContent);\n      \n      // Validate response structure\n      if (!llmResponse.workout_plan) {\n        throw new Error('LLM response missing workout_plan');\n      }\n      \n      return {\n        workout_plan: llmResponse.workout_plan,\n        rationale: llmResponse.rationale || 'No rationale provided',\n        confidence_score: llmResponse.confidence_score || 0.8,\n        exercise_suggestions: llmResponse.exercise_suggestions || [],\n        usage: completion.usage\n      };\n      \n    } catch (error) {\n      if (error.code === 'context_length_exceeded') {\n        throw new Error('Workout request too complex. Please simplify or break into multiple requests.');\n      }\n      throw new Error(`LLM generation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Build comprehensive generation prompt\n   */\n  buildGenerationPrompt(context, options) {\n    const basePrompt = WorkoutPrompts.getWorkoutGenerationPrompt(context.request);\n    \n    let prompt = basePrompt;\n    \n    // Add safety reminders based on user level\n    prompt += WorkoutPrompts.getSafetyReminderPrompt(\n      context.constraints.fitness_level,\n      context.constraints.injury_considerations\n    );\n    \n    // Add equipment-specific guidance\n    prompt += WorkoutPrompts.getEquipmentGuidancePrompt(context.available_equipment);\n    \n    // Add time-specific guidance if duration specified\n    const duration = options.target_duration || \n                    this.extractDurationFromRequest(context.request) ||\n                    context.constraints.max_workout_duration;\n    prompt += WorkoutPrompts.getTimeGuidancePrompt(duration);\n    \n    // Add context summary\n    prompt += `\\n\\nCONTEXT SUMMARY:\\n`;\n    prompt += `- Available exercises: ${context.exercise_library.total_exercises}\\n`;\n    prompt += `- Recent workouts (7d): ${context.recent_history_7d.total_workouts}\\n`;\n    prompt += `- Recovery status: ${context.recent_history_7d.recovery_status}\\n`;\n    prompt += `- Average RPE: ${context.recent_history_7d.average_rpe?.toFixed(1) || 'N/A'}\\n`;\n    prompt += `- Equipment: ${context.available_equipment.join(', ')}\\n`;\n    \n    if (context.is_deload_week) {\n      prompt += `\\n🚨 DELOAD WEEK DETECTED - Reduce intensity and volume by 40-60%\\n`;\n    }\n    \n    // Add specific workout requirements based on request type\n    prompt += this.addSpecificRequirements(context.request, context);\n    \n    return prompt;\n  }\n\n  /**\n   * Apply final safety checks before saving workout\n   */\n  async applySafetyChecks(workoutPlan, context) {\n    const issues = [];\n    \n    // Check overall workout RPE against user level\n    const maxRPE = this.getMaxRPEForUser(context.constraints.fitness_level);\n    if (workoutPlan.overall_rpe_target > maxRPE) {\n      issues.push(`Planned RPE ${workoutPlan.overall_rpe_target} exceeds safe limit of ${maxRPE} for ${context.constraints.fitness_level} user`);\n    }\n    \n    // Check total volume against progression limits\n    const recentVolume = context.recent_history_7d.total_volume_kg / context.recent_history_7d.total_workouts;\n    const plannedVolume = this.estimateWorkoutVolume(workoutPlan);\n    const volumeIncrease = (plannedVolume - recentVolume) / recentVolume;\n    \n    if (volumeIncrease > this.safetySettings.progressionCap) {\n      issues.push(`Volume increase of ${(volumeIncrease * 100).toFixed(1)}% exceeds safe progression limit`);\n    }\n    \n    // Check for movement pattern conflicts with recent training\n    const conflictCheck = await this.checkMovementPatternConflicts(workoutPlan, context);\n    if (conflictCheck.conflicts.length > 0) {\n      issues.push(`Movement pattern conflicts: ${conflictCheck.conflicts.join(', ')}`);\n    }\n    \n    return {\n      safe: issues.length === 0,\n      issues\n    };\n  }\n\n  // Helper methods\n  validateInputs(userId, request) {\n    if (!userId || typeof userId !== 'string') {\n      throw new Error('Invalid user ID');\n    }\n    \n    if (!request || typeof request !== 'string' || request.trim().length < 3) {\n      throw new Error('Invalid workout request');\n    }\n    \n    if (request.length > 1000) {\n      throw new Error('Workout request too long');\n    }\n  }\n\n  shouldDeload(history14d) {\n    // Simple deload detection - enhance with more sophisticated logic\n    return history14d.total_workouts >= 12 && history14d.average_rpe > 8.5;\n  }\n\n  calculateCurrentFatigue(history7d) {\n    return history7d.fatigue_scores || {};\n  }\n\n  calculateVolumeTargets(history14d, options) {\n    const baseVolume = history14d.total_volume_kg / 14; // Daily average\n    return {\n      target_volume: baseVolume * (1 + (options.progression_rate || 0.1)),\n      min_volume: baseVolume * 0.8,\n      max_volume: baseVolume * 1.2\n    };\n  }\n\n  inferRequiredEquipment(request) {\n    const equipment = [];\n    const requestLower = request.toLowerCase();\n    \n    if (requestLower.includes('barbell') || requestLower.includes('squat') || \n        requestLower.includes('deadlift') || requestLower.includes('bench')) {\n      equipment.push('barbell', 'weight_plates');\n    }\n    \n    if (requestLower.includes('dumbbell')) {\n      equipment.push('dumbbells');\n    }\n    \n    if (requestLower.includes('cable') || requestLower.includes('machine')) {\n      equipment.push('cable_machine');\n    }\n    \n    return [...new Set(equipment)];\n  }\n\n  extractDurationFromRequest(request) {\n    const durationMatch = request.match(/(\\d+)\\s*(min|minute|hour)/i);\n    if (durationMatch) {\n      const value = parseInt(durationMatch[1]);\n      const unit = durationMatch[2].toLowerCase();\n      return unit.startsWith('hour') ? value * 60 : value;\n    }\n    return null;\n  }\n\n  getMaxRPEForUser(fitnessLevel) {\n    const rpeMap = {\n      beginner: this.safetySettings.maxRPEBeginner,\n      intermediate: this.safetySettings.maxRPEIntermediate,\n      advanced: this.safetySettings.maxRPEAdvanced\n    };\n    return rpeMap[fitnessLevel] || 8;\n  }\n\n  estimateWorkoutVolume(workoutPlan) {\n    let totalVolume = 0;\n    workoutPlan.blocks.forEach(block => {\n      block.exercises.forEach(exercise => {\n        exercise.sets.forEach(set => {\n          totalVolume += (set.weight || 0) * (set.reps || 0);\n        });\n      });\n    });\n    return totalVolume;\n  }\n\n  async checkMovementPatternConflicts(workoutPlan, context) {\n    // Simplified conflict detection - enhance with more sophisticated logic\n    return { conflicts: [] };\n  }\n\n  addSpecificRequirements(request, context) {\n    let requirements = `\\n\\nSPECIFIC REQUIREMENTS:\\n`;\n    \n    const requestLower = request.toLowerCase();\n    \n    if (requestLower.includes('strength')) {\n      requirements += `- Focus on compound movements\\n- Rep ranges: 1-8 for strength, 6-12 for hypertrophy\\n- RPE: 7-9 for working sets\\n`;\n    }\n    \n    if (requestLower.includes('cardio') || requestLower.includes('conditioning')) {\n      requirements += `- Emphasize metabolic conditioning\\n- Include work:rest ratios\\n- Monitor heart rate zones\\n`;\n    }\n    \n    if (requestLower.includes('upper')) {\n      requirements += `- Focus on upper body exercises\\n- Balance push/pull movements\\n`;\n    }\n    \n    if (requestLower.includes('lower')) {\n      requirements += `- Focus on lower body exercises\\n- Include hip-dominant and knee-dominant patterns\\n`;\n    }\n    \n    return requirements;\n  }\n\n  summarizeContext(context) {\n    return {\n      exercise_count: context.exercise_library.total_exercises,\n      equipment: context.available_equipment.length,\n      recent_workouts: context.recent_history_7d.total_workouts,\n      recovery_status: context.recent_history_7d.recovery_status,\n      is_deload: context.is_deload_week\n    };\n  }\n\n  // Logging methods for analytics and debugging\n  async logGenerationSuccess(userId, workoutId, metadata) {\n    try {\n      await this.db('llm_generation_log').insert({\n        id: uuidv4(),\n        user_id: userId,\n        workout_id: workoutId,\n        generation_id: metadata.generation_id,\n        success: true,\n        ...metadata,\n        created_at: new Date()\n      });\n    } catch (error) {\n      console.error('Failed to log generation success:', error);\n    }\n  }\n\n  async logGenerationFailure(userId, request, validation, generationId) {\n    try {\n      await this.db('llm_generation_log').insert({\n        id: uuidv4(),\n        user_id: userId,\n        generation_id: generationId,\n        success: false,\n        request_text: request,\n        error_details: JSON.stringify(validation),\n        created_at: new Date()\n      });\n    } catch (error) {\n      console.error('Failed to log generation failure:', error);\n    }\n  }\n\n  async logGenerationError(userId, request, error, generationId) {\n    try {\n      await this.db('llm_generation_log').insert({\n        id: uuidv4(),\n        user_id: userId,\n        generation_id: generationId,\n        success: false,\n        request_text: request,\n        error_details: error.message,\n        created_at: new Date()\n      });\n    } catch (error) {\n      console.error('Failed to log generation error:', error);\n    }\n  }\n}\n\nmodule.exports = { WorkoutGenerationService };"