/**\n * Exercise suggestion and approval workflow system\n * Handles exercises not found in user's library\n * @file suggestion-system.js\n */\n\nconst { v4: uuidv4 } = require('uuid');\n\nclass ExerciseSuggestionSystem {\n  constructor(db) {\n    this.db = db;\n    this.suggestionStatus = {\n      PENDING: 'pending',\n      APPROVED: 'approved',\n      REJECTED: 'rejected',\n      AUTO_APPROVED: 'auto_approved'\n    };\n    \n    // Auto-approval rules\n    this.autoApprovalRules = {\n      // Approve basic bodyweight exercises automatically\n      bodyweight_basics: [\n        'push-up', 'pull-up', 'squat', 'lunge', 'plank',\n        'mountain climbers', 'burpees', 'jumping jacks'\n      ],\n      \n      // Approve common variations of existing exercises\n      common_variations: [\n        'incline', 'decline', 'single-arm', 'single-leg',\n        'pause', 'tempo', 'isometric', 'pulsing'\n      ],\n      \n      // Equipment-based auto-approvals\n      equipment_variations: {\n        'dumbbell': ['dumbbell', 'db'],\n        'barbell': ['barbell', 'bb'],\n        'cable': ['cable', 'machine'],\n        'resistance_band': ['band', 'resistance']\n      }\n    };\n  }\n\n  /**\n   * Process exercise suggestions from workout generation\n   * @param {string} userId - User identifier\n   * @param {Array} suggestions - Array of exercise suggestions\n   * @returns {Promise<Object>} Processing results\n   */\n  async processSuggestions(userId, suggestions) {\n    const results = {\n      total_suggestions: suggestions.length,\n      auto_approved: [],\n      pending_approval: [],\n      duplicates_found: [],\n      errors: []\n    };\n\n    try {\n      // Check for existing suggestions to avoid duplicates\n      const existingSuggestions = await this.getExistingSuggestions(userId);\n      const existingNames = new Set(\n        existingSuggestions.map(s => s.suggested_name.toLowerCase())\n      );\n\n      for (const suggestion of suggestions) {\n        try {\n          // Skip if already suggested\n          if (existingNames.has(suggestion.suggested_name.toLowerCase())) {\n            results.duplicates_found.push(suggestion.suggested_name);\n            continue;\n          }\n\n          // Check if exercise already exists in user's library\n          const existsInLibrary = await this.checkExerciseInLibrary(\n            userId, suggestion.suggested_name\n          );\n\n          if (existsInLibrary) {\n            results.duplicates_found.push(suggestion.suggested_name);\n            continue;\n          }\n\n          // Check for auto-approval\n          const autoApprovalResult = this.checkAutoApproval(\n            suggestion, existingSuggestions\n          );\n\n          if (autoApprovalResult.should_auto_approve) {\n            const approvedSuggestion = await this.autoApproveSuggestion(\n              userId, suggestion, autoApprovalResult.reason\n            );\n            results.auto_approved.push(approvedSuggestion);\n          } else {\n            // Add to pending approval\n            const pendingSuggestion = await this.createPendingSuggestion(\n              userId, suggestion\n            );\n            results.pending_approval.push(pendingSuggestion);\n          }\n\n        } catch (error) {\n          results.errors.push({\n            exercise: suggestion.suggested_name,\n            error: error.message\n          });\n        }\n      }\n\n      return results;\n\n    } catch (error) {\n      throw new Error(`Failed to process suggestions: ${error.message}`);\n    }\n  }\n\n  /**\n   * Check if suggestion should be auto-approved\n   */\n  checkAutoApproval(suggestion, existingExercises) {\n    const exerciseName = suggestion.suggested_name.toLowerCase();\n    \n    // Check bodyweight basics\n    const isBodyweightBasic = this.autoApprovalRules.bodyweight_basics.some(\n      basic => exerciseName.includes(basic)\n    );\n    \n    if (isBodyweightBasic) {\n      return {\n        should_auto_approve: true,\n        reason: 'bodyweight_basic',\n        confidence: 0.95\n      };\n    }\n    \n    // Check for common variations of existing exercises\n    const isCommonVariation = this.checkForVariation(\n      exerciseName, existingExercises\n    );\n    \n    if (isCommonVariation.is_variation) {\n      return {\n        should_auto_approve: true,\n        reason: 'common_variation',\n        base_exercise: isCommonVariation.base_exercise,\n        confidence: isCommonVariation.confidence\n      };\n    }\n    \n    // Check equipment-based variations\n    const equipmentMatch = this.checkEquipmentVariation(\n      exerciseName, suggestion.equipment_needed\n    );\n    \n    if (equipmentMatch.should_approve) {\n      return {\n        should_auto_approve: true,\n        reason: 'equipment_variation',\n        equipment_type: equipmentMatch.equipment_type,\n        confidence: equipmentMatch.confidence\n      };\n    }\n    \n    return {\n      should_auto_approve: false,\n      reason: 'requires_manual_review'\n    };\n  }\n\n  /**\n   * Check if suggestion is a variation of existing exercise\n   */\n  checkForVariation(suggestionName, existingExercises) {\n    const variationKeywords = this.autoApprovalRules.common_variations;\n    \n    for (const exercise of existingExercises) {\n      const baseName = exercise.name.toLowerCase();\n      \n      // Remove variation keywords from both names\n      const cleanBaseName = this.removeVariationKeywords(baseName);\n      const cleanSuggestionName = this.removeVariationKeywords(suggestionName);\n      \n      // Check if base names match\n      if (this.namesMatch(cleanBaseName, cleanSuggestionName)) {\n        // Check if suggestion has variation keywords\n        const hasVariationKeyword = variationKeywords.some(\n          keyword => suggestionName.includes(keyword)\n        );\n        \n        if (hasVariationKeyword) {\n          return {\n            is_variation: true,\n            base_exercise: exercise.name,\n            confidence: 0.85\n          };\n        }\n      }\n    }\n    \n    return { is_variation: false };\n  }\n\n  /**\n   * Check equipment-based variations\n   */\n  checkEquipmentVariation(exerciseName, suggestedEquipment) {\n    for (const [equipmentType, keywords] of Object.entries(\n      this.autoApprovalRules.equipment_variations\n    )) {\n      const hasEquipmentKeyword = keywords.some(\n        keyword => exerciseName.includes(keyword)\n      );\n      \n      const equipmentMatches = suggestedEquipment?.some(\n        eq => eq.toLowerCase().includes(equipmentType)\n      );\n      \n      if (hasEquipmentKeyword && equipmentMatches) {\n        return {\n          should_approve: true,\n          equipment_type: equipmentType,\n          confidence: 0.80\n        };\n      }\n    }\n    \n    return { should_approve: false };\n  }\n\n  /**\n   * Auto-approve and add exercise to library\n   */\n  async autoApproveSuggestion(userId, suggestion, reason) {\n    const trx = await this.db.transaction();\n    \n    try {\n      // Create exercise record\n      const exerciseId = uuidv4();\n      const exerciseData = {\n        id: exerciseId,\n        name: suggestion.suggested_name,\n        description: `Auto-generated from suggestion: ${suggestion.reason}`,\n        category: suggestion.category || 'strength',\n        muscle_groups: JSON.stringify(suggestion.muscle_groups || []),\n        equipment_needed: JSON.stringify(suggestion.equipment_needed || []),\n        difficulty_level: this.inferDifficultyLevel(suggestion),\n        instructions: `Auto-approved ${suggestion.suggested_name}. Please add detailed instructions.`,\n        is_active: true,\n        is_custom: true,\n        created_by: userId\n      };\n      \n      await trx('exercises').insert(exerciseData);\n      \n      // Add to user's library\n      await trx('user_exercise_library').insert({\n        id: uuidv4(),\n        user_id: userId,\n        exercise_id: exerciseId,\n        is_active: true,\n        added_date: new Date()\n      });\n      \n      // Log the suggestion\n      const suggestionRecord = {\n        id: uuidv4(),\n        user_id: userId,\n        exercise_id: exerciseId,\n        suggested_name: suggestion.suggested_name,\n        reason: suggestion.reason,\n        muscle_groups: JSON.stringify(suggestion.muscle_groups || []),\n        equipment_needed: JSON.stringify(suggestion.equipment_needed || []),\n        category: suggestion.category,\n        status: this.suggestionStatus.AUTO_APPROVED,\n        auto_approval_reason: reason,\n        created_at: new Date(),\n        processed_at: new Date()\n      };\n      \n      await trx('exercise_suggestions').insert(suggestionRecord);\n      \n      await trx.commit();\n      \n      return {\n        ...suggestionRecord,\n        exercise_data: exerciseData\n      };\n      \n    } catch (error) {\n      await trx.rollback();\n      throw new Error(`Failed to auto-approve suggestion: ${error.message}`);\n    }\n  }\n\n  /**\n   * Create pending suggestion for manual approval\n   */\n  async createPendingSuggestion(userId, suggestion) {\n    try {\n      const suggestionRecord = {\n        id: uuidv4(),\n        user_id: userId,\n        suggested_name: suggestion.suggested_name,\n        reason: suggestion.reason,\n        muscle_groups: JSON.stringify(suggestion.muscle_groups || []),\n        equipment_needed: JSON.stringify(suggestion.equipment_needed || []),\n        category: suggestion.category || 'strength',\n        status: this.suggestionStatus.PENDING,\n        created_at: new Date()\n      };\n      \n      await this.db('exercise_suggestions').insert(suggestionRecord);\n      \n      return suggestionRecord;\n      \n    } catch (error) {\n      throw new Error(`Failed to create pending suggestion: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get user's pending suggestions\n   */\n  async getPendingSuggestions(userId) {\n    try {\n      return await this.db('exercise_suggestions')\n        .where('user_id', userId)\n        .where('status', this.suggestionStatus.PENDING)\n        .orderBy('created_at', 'desc');\n    } catch (error) {\n      throw new Error(`Failed to get pending suggestions: ${error.message}`);\n    }\n  }\n\n  /**\n   * Approve a pending suggestion\n   */\n  async approveSuggestion(userId, suggestionId, additionalData = {}) {\n    const trx = await this.db.transaction();\n    \n    try {\n      // Get suggestion\n      const suggestion = await trx('exercise_suggestions')\n        .where('id', suggestionId)\n        .where('user_id', userId)\n        .where('status', this.suggestionStatus.PENDING)\n        .first();\n      \n      if (!suggestion) {\n        throw new Error('Suggestion not found or already processed');\n      }\n      \n      // Create exercise\n      const exerciseId = uuidv4();\n      const exerciseData = {\n        id: exerciseId,\n        name: additionalData.name || suggestion.suggested_name,\n        description: additionalData.description || `User-approved: ${suggestion.reason}`,\n        category: additionalData.category || suggestion.category,\n        muscle_groups: JSON.stringify(\n          additionalData.muscle_groups || JSON.parse(suggestion.muscle_groups || '[]')\n        ),\n        equipment_needed: JSON.stringify(\n          additionalData.equipment_needed || JSON.parse(suggestion.equipment_needed || '[]')\n        ),\n        difficulty_level: additionalData.difficulty_level || this.inferDifficultyLevel(suggestion),\n        instructions: additionalData.instructions || 'User-approved exercise. Please add instructions.',\n        video_url: additionalData.video_url,\n        is_active: true,\n        is_custom: true,\n        created_by: userId\n      };\n      \n      await trx('exercises').insert(exerciseData);\n      \n      // Add to user's library\n      await trx('user_exercise_library').insert({\n        id: uuidv4(),\n        user_id: userId,\n        exercise_id: exerciseId,\n        is_active: true,\n        added_date: new Date()\n      });\n      \n      // Update suggestion status\n      await trx('exercise_suggestions')\n        .where('id', suggestionId)\n        .update({\n          exercise_id: exerciseId,\n          status: this.suggestionStatus.APPROVED,\n          processed_at: new Date(),\n          approval_notes: additionalData.approval_notes\n        });\n      \n      await trx.commit();\n      \n      return {\n        exercise_id: exerciseId,\n        exercise_data: exerciseData,\n        suggestion_id: suggestionId\n      };\n      \n    } catch (error) {\n      await trx.rollback();\n      throw new Error(`Failed to approve suggestion: ${error.message}`);\n    }\n  }\n\n  /**\n   * Reject a pending suggestion\n   */\n  async rejectSuggestion(userId, suggestionId, reason = null) {\n    try {\n      const updated = await this.db('exercise_suggestions')\n        .where('id', suggestionId)\n        .where('user_id', userId)\n        .where('status', this.suggestionStatus.PENDING)\n        .update({\n          status: this.suggestionStatus.REJECTED,\n          processed_at: new Date(),\n          rejection_reason: reason\n        });\n      \n      if (updated === 0) {\n        throw new Error('Suggestion not found or already processed');\n      }\n      \n      return { success: true, suggestion_id: suggestionId };\n      \n    } catch (error) {\n      throw new Error(`Failed to reject suggestion: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get suggestion analytics for user\n   */\n  async getSuggestionAnalytics(userId) {\n    try {\n      const analytics = await this.db('exercise_suggestions')\n        .where('user_id', userId)\n        .select(\n          this.db.raw('COUNT(*) as total_suggestions'),\n          this.db.raw(\"COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count\"),\n          this.db.raw(\"COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_count\"),\n          this.db.raw(\"COUNT(CASE WHEN status = 'auto_approved' THEN 1 END) as auto_approved_count\"),\n          this.db.raw(\"COUNT(CASE WHEN status = 'rejected' THEN 1 END) as rejected_count\")\n        )\n        .first();\n      \n      // Get category breakdown\n      const categoryBreakdown = await this.db('exercise_suggestions')\n        .where('user_id', userId)\n        .select('category')\n        .count('* as count')\n        .groupBy('category');\n      \n      // Get recent suggestions\n      const recentSuggestions = await this.db('exercise_suggestions')\n        .where('user_id', userId)\n        .orderBy('created_at', 'desc')\n        .limit(10)\n        .select(['id', 'suggested_name', 'status', 'created_at', 'reason']);\n      \n      return {\n        ...analytics,\n        category_breakdown: categoryBreakdown,\n        recent_suggestions: recentSuggestions,\n        approval_rate: analytics.total_suggestions > 0 \n          ? ((analytics.approved_count + analytics.auto_approved_count) / analytics.total_suggestions * 100).toFixed(1)\n          : 0\n      };\n      \n    } catch (error) {\n      throw new Error(`Failed to get suggestion analytics: ${error.message}`);\n    }\n  }\n\n  // Helper methods\n  async getExistingSuggestions(userId) {\n    return await this.db('exercises')\n      .where('created_by', userId)\n      .orWhere('is_custom', false)\n      .select(['name', 'id']);\n  }\n\n  async checkExerciseInLibrary(userId, exerciseName) {\n    const exercise = await this.db('exercises')\n      .leftJoin('user_exercise_library', function() {\n        this.on('exercises.id', '=', 'user_exercise_library.exercise_id')\n            .andOn('user_exercise_library.user_id', '=', this.db.raw('?', [userId]));\n      })\n      .where('exercises.name', 'ilike', `%${exerciseName}%`)\n      .where(function() {\n        this.where('exercises.is_custom', false)\n            .orWhere('exercises.created_by', userId)\n            .orWhere('user_exercise_library.is_active', true);\n      })\n      .first();\n    \n    return !!exercise;\n  }\n\n  removeVariationKeywords(name) {\n    let cleanName = name;\n    this.autoApprovalRules.common_variations.forEach(keyword => {\n      cleanName = cleanName.replace(new RegExp(keyword, 'gi'), '').trim();\n    });\n    return cleanName;\n  }\n\n  namesMatch(name1, name2) {\n    // Simple fuzzy matching - could be enhanced with more sophisticated algorithms\n    const similarity = this.calculateSimilarity(name1, name2);\n    return similarity > 0.8; // 80% similarity threshold\n  }\n\n  calculateSimilarity(str1, str2) {\n    // Simple Jaccard similarity\n    const set1 = new Set(str1.split(' '));\n    const set2 = new Set(str2.split(' '));\n    const intersection = new Set([...set1].filter(x => set2.has(x)));\n    const union = new Set([...set1, ...set2]);\n    return intersection.size / union.size;\n  }\n\n  inferDifficultyLevel(suggestion) {\n    const name = suggestion.suggested_name.toLowerCase();\n    \n    // Basic inference rules\n    if (name.includes('beginner') || name.includes('easy')) return 'beginner';\n    if (name.includes('advanced') || name.includes('complex')) return 'advanced';\n    if (suggestion.muscle_groups?.length > 3) return 'advanced';\n    if (suggestion.equipment_needed?.includes('bodyweight')) return 'beginner';\n    \n    return 'intermediate'; // Default\n  }\n}\n\nmodule.exports = { ExerciseSuggestionSystem };"